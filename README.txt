"# p5" 
Alexander Sung
Ruben Calderon

This file aims to describe our implementation of an A*-based planner that makes use of a heuristic to complete minecraft
recipes to build items or accomplish tasks. 

Heuristic:
Our heuristic guidelines entail limiting specific items that allow work to be done more efficiently to just 1. These items include bench, furnace, iron_axe, iron_pickaxe, stone_axe, stone_pickaxe, wooden_axe, and wooden_pickaxe. We ensure that only 1 of these items can be present in our inventory at a given time. If we have a final goal that requires these items to be built in order to reach other states of the goal, then we build the items we need only once. Once we have the items we need, we don't need to rebuild them again because we already have one. Having one of these items will get the job done and finding the final path to the end goal is easier because we don't have to keep recreating items we only need one of. In addition, our heuristic limits the number of items needed to craft another more important item. Specifically, we limited the number of smaller items to a maximum of 10; these items include cart, coal, cobble, ingot, ore, plank, rail, stick, and wood. Since there is an unlimited amount of materials we can produce from farming, we limited the quantity for each of these materials to allow the search algorithm to not create more materials than needed. For instance, the largest quantity of materials needed to build a furnace is 8 cobble. By limiting the quantity of each material in our inventory, our algorithm can work more quickly and efficiently. 

Search Algorithm:
Our A*-based planner algorithm utilizes a priority queue that takes in different rules and the total time it takes to reach that state by performing the actions set by the rules. Each recipe has its own name, preconditions, effects, and execution times. Since we started with nothing, the algorithm will search through the list of recipes found in the crafting.json file while checking with the heuristic to make sure the items created are limited correspondingly, allowing us to find the optimal path of which items are needed to be produced first in order to get the materials needed to reach the final goal. The algorithm checks the current state (starting from the initial empty state) and calculates the next state needed to move forwards towards the goal. If the time after following the next state's rules is better than another state's rules, then we will consider the path that takes the least time of action. Ultimately, our algorithm will compile the most optimal path starting from nothing and following a sequence of actions that will lead to the final goal. If the final goal is unreachable, a message will be printed to the console saying so. 